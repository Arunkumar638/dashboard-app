<div><h2><b>Function basics</b></h2>
In C, a function is a self-contained block of code that performs a specific task. Functions provide modularity and allow you to organize your code into smaller, manageable pieces. Here are the basics of defining and using functions in C:<br/>
<h3><b>Function Declaration and Definition:</b></h3>
<b>Function Declaration:</b><br/>
   A function declaration tells the compiler about the existence of a function. It
specifies the function's name, return type, and parameters (if any).<br/>
   It's also known as the function prototype.<br/>
return_type function_name(parameter1_type parameter1_name, parameter2_type parameter2_name, ...);<br/>
<b>Example:</b><br/>
	int add(int a, int b); // Function declaration for an addition function<br/>
<b>Function Definition:</b><br/>
 A function definition provides the actual implementation of the function. It contains the code that is executed when the function is called.<br/>
 The function definition includes the function's body.<br/>
	return_type function_name(parameter1_type parameter1_name, parameter2_type parameter2_name, ...) {<br/>
    	// Function body<br/>
    	// ...<br/>
    	return return_value; // Return statement (if the function has a return type)<br/>
	}<br/>
<b>Example:</b><br/>
    int add(int a, int b) {<br/>
        int sum = a + b;<br/>
        return sum;<br/>
    }<br/>
<b>Calling a Function:</b><br/>
To use a function, you need to call it from your program. You do this by using the function name followed by parentheses. If the function has parameters, you pass the actual values (arguments) inside the parentheses.<br/>
<b>Example:</b><br/>
int result = add(3, 4); // Calling the add function and storing the result in the variable 'result'<br/>
<b>Function Return Type:</b><br/>
The return type of a function specifies the type of value that the function will return. If a function doesn't return anything, its return type is void.<br/>
<b>Example:</b><br/>
int add(int a, int b) {<br/>
    int sum = a + b;<br/>
    return sum; // The return type of this function is 'int'<br/>
}<br/>
void greet() {<br/>
    printf("Hello!\n");<br/>
    // This function doesn't return anything (return type is 'void')<br/>
}<br/>
<b>Function Parameters:</b><br/>
Parameters are the values that a function receives when it's called. They allow you to pass data into a function.<br/>
<b>Example:</b><br/>
int add(int a, int b) {<br/>
    int sum = a + b;<br/>
    return sum;<br/>
}<br/>
int main() {<br/>
    int result = add(3, 4); // 'a' is 3, 'b' is 4<br/>
    printf("Result: %d\n", result); // Output: Result: 7<br/>
    return 0;<br/>
}<br/>
<b>Function Call Stack:</b><br/>
When a function is called, the program execution jumps to the function's code. The variables and parameters of the function are stored in a memory area called the "stack frame". When the function finishes executing, it returns control to the calling function.<br/>
<b>Recursive Functions:</b><br/>
A recursive function is a function that calls itself. This technique is useful for solving problems that can be broken down into smaller, similar sub-problems.<br/>
<b>Example:</b><br/>
int factorial(int n) {<br/>
    if (n == 0) {<br/>
        return 1;<br/>
    } else {<br/>
        return n * factorial(n - 1);<br/>
    }<br/>
}<br/>
These are the basic concepts of functions in C. They are a fundamental part of programming, enabling you to organize code, reuse logic, and build complex applications.<br/>
<h2><b>Function with input parameter example</b></h2>
Certainly! Here's an example of a C function that takes two integers as input parameters and returns their sum:<br/>
#include &lt;stdio.h&gt;<br/>
// Function declaration (prototype)<br/>
int add(int a, int b);<br/>
int main() {<br/>
    int num1 = 5;<br/>
    int num2 = 7;<br/>
    // Calling the function and storing the result in 'sum'<br/>
    int sum = add(num1, num2);<br/>
    printf("The sum of %d and %d is %d\n", num1, num2, sum);<br/>
    return 0;<br/>
}<br/>
// Function definition<br/>
int add(int a, int b) {<br/>
    int result = a + b;<br/>
    return result;<br/>
}<br/>
<b>Output:</b><br/>
	The sum of 5 and 7 is 12<br/>
<b>Explanation:</b><br/>
<li>We have a function named add that takes two integer parameters (a and b) and returns an integer.<br/>
<li>In the main function, we declare two variables num1 and num2 and initialize them with the values 5 and 7.<br/>
<li>We then call the add function, passing num1 and num2 as arguments. The result is stored in the variable sum.<br/>
<li>Finally, we print out the result using printf.<br/>
In this example, the add function takes two integers (a and b) as input parameters, adds them together, and returns the result. The main function calls this add function with num1 and num2 as arguments and prints out the result.<br/>
<h2><b>Function Call by value example</b></h2>
In C, when you pass parameters to a function, they are passed by value by default. This means that the function receives a copy of the values, and any changes made to the parameters inside the function do not affect the original variables. Here's an example to illustrate call by value:<br/>
#include &lt;stdio.h&gt;<br/>
void square(int num) {<br/>
    num = num * num;<br/>
    printf("Inside function: %d\n", num);<br/>
}<br/>
int main() {<br/>
    int number = 5;<br/>
    printf("Before function call: %d\n", number);<br/>
    square(number);<br/>
    printf("After function call: %d\n", number);<br/>
    return 0;<br/>
}<br/>
<b>Output:</b><br/>
Before function call: 5<br/>
Inside function: 25<br/>
After function call: 5<br/>
<b>Explanation:</b><br/>
</li>We have a function named square that takes an integer num as a parameter. Inside the function, it calculates the square of num and prints it.<br/>
<li>In the main function, we declare an integer variable number and initialize it with the value 5.<br/>
<li>We then call the square function, passing number as an argument.<br/>
<li>Inside the square function, num is a local variable. When we calculate the square, it only affects the local copy of num.<br/>
<li>After the function call, we print out the value of number in the main function. As you can see, the original value of number remains unchanged.<br/>
<li>This demonstrates call by value, where the function receives a copy of the value, and any changes made to the parameter inside the function do not affect the original variable in the calling function.<br/>
<h2><b>Function call by reference example</b></h2>
In C, you can pass parameters to a function by reference, which allows the function to directly access and modify the original variables. This is achieved by passing pointers to the variables. Here's an example to illustrate call by reference:<br/>
#include &lt;stdio.h&gt;<br/>
void square(int *num) {<br/>
    *num = (*num) * (*num);<br/>
    printf("Inside function: %d\n", *num);<br/>
}<br/>
int main() {<br/>
    int number = 5;<br/>
    printf("Before function call: %d\n", number);<br/>
    square(&number);<br/>
    printf("After function call: %d\n", number);<br/>
    return 0;<br/>
}<br/>
<b>Output:</b><br/>
Before function call: 5<br/>
Inside function: 25<br/>
After function call: 25<br/>
<b>Explanation:</b><br/>
<li>We have a function named square that takes a pointer to an integer num as a parameter. Inside the function, it dereferences the pointer to access the original variable, calculates the square of num, and updates the original variable.<br/>
<li>In the main function, we declare an integer variable number and initialize it with the value 5.<br/>
<li>When calling the square function, we pass the address of number using the & operator. This passes a pointer to the original variable.<br/>
I<li>nside the square function, num is a pointer to the original variable. We dereference it using *num to access and modify the original value.<br/>
<li>After the function call, we print out the value of number in the main function. As you can see, the original value of number has been updated.<br/>
<li>This demonstrates call by reference, where the function receives a pointer to the original variable, allowing it to directly modify the variable in the calling function.<br/>
<h2><b>Recursion and inline function in C</b></h2>
<b>Recursion:</b><br/>
Recursion is a programming technique where a function calls itself in order to solve a problem. To use recursion effectively, you need to break the problem down into smaller, similar sub-problems.<br/>
Here's an example of a recursive function to calculate the factorial of a non-negative integer:<br/>
#include &lt;stdio.h&gt;<br/>
unsigned int factorial(unsigned int n) {<br/>
    if (n == 0) {<br/>
        return 1;<br/>
    } else {<br/>
        return n * factorial(n - 1);<br/>
    }<br/>
}<br/>
int main() {<br/>
    unsigned int n = 5;<br/>
    unsigned int result = factorial(n);<br/>
    printf("Factorial of %u is %u\n", n, result);<br/>
    return 0;<br/>
}<br/>
<b>Output:</b><br/>
Factorial of 5 is 120<br/>
In this example, the factorial function calls itself with a smaller value (n - 1) until it reaches the base case (n == 0). The base case is important to prevent infinite recursion.<br/>
<b>Inline Functions:</b><br/>
In C, the inline keyword suggests to the compiler that it should attempt to generate code for a function inline, rather than making a function call. This can lead to faster execution because there's no overhead of a function call.<br/>
Here's an example of an inline function:<br/>
#include &lt;stdio.h&gt;<br/>
inline int add(int a, int b) {<br/>
    return a + b;<br/>
}<br/>
int main() {<br/>
    int result = add(3, 4);<br/>
    printf("Result: %d\n", result);<br/>
    return 0;<br/>
}<br/>
<b>Output:</b><br/>
	Result: 7<br/>
The inline keyword is used before the function definition. It's a suggestion to the compiler, and the compiler may choose to ignore it.<br/>
Note that the effectiveness of inlining depends on various factors, including the size of the function and the optimization settings of the compiler. The compiler will decide whether it's appropriate to actually inline the function.<br/>
Inlining is generally used for small, frequently called functions where the overhead of a function call might be significant. <br/>
</div>